# 红点系统

本文档基于当前工程实现，完整说明红点系统的架构、运行链路与关键设计点。

## 1. 设计目标

- 将“显示位置”和“计算逻辑”解耦：红点名只关心显示，红点运算单元只关心计算。
- 支持静态红点与动态（带 ID）红点共存。
- 支持多对多组合：一个红点名可由多个单元组成，一个单元可影响多个红点名。
- 通过 `MarkDirty` 驱动增量重算，避免每帧全量计算。
- 支持聚合单元（Composite），让静态红点可基于动态单元结果聚合。

---

## 2. 核心角色与职责

### 2.1 RedDotModel（数据与配置中心）

文件：`Assets/Scripts/ReddotSystem/GameLogic/RedDotSystem/RedDotModel.cs`

职责：

- 持有红点名配置（`RedDotInfo`）
- 持有红点运算单元配置（`RedDotUnitInfo`）
- 持有运行时缓存（unit 结果、name 结果）
- 维护索引关系（unit -> names、unit 依赖反向图）
- 提供动态红点注册/注销能力（带 ID）

### 2.2 RedDotManager（调度与计算中心）

文件：`Assets/Scripts/ReddotSystem/GameLogic/RedDotSystem/RedDotManager.cs`

职责：

- 维护脏集合（非 ID、带 ID）
- 在 `Update()` 中按固定帧间隔处理 dirty
- 执行单元计算、聚合计算、name 聚合与回调触发
- 提供绑定/解绑与“绑定后回放当前值”能力

### 2.3 RedDotInfo（红点名节点）

文件：`Assets/Scripts/ReddotSystem/GameLogic/RedDotSystem/RedDotInfo.cs`

职责：

- 描述一个红点名（name、描述、关联 unit 列表）
- 维护 UI 回调集合（Bind/UnBind/TriggerUpdate）
- 支持带 ID 名称（`Id`、`IsIdBased`）

### 2.4 RedDotUnitInfo（运算单元定义）

文件：`Assets/Scripts/ReddotSystem/GameLogic/RedDotSystem/RedDotUnitInfo.cs`

职责：

- 描述单元类型与计算方式
  - `LEAF`：叶子单元（直接函数计算）
  - `COMPOSITE`：聚合单元（依赖其他 unit 缓存）
- 支持聚合模式
  - `SUM`
  - `ANY_POSITIVE`

---

## 3. 关键抽象

### 3.1 红点名（RedDotName）

- 语义：UI 上“显示在哪里”。
- 例如：`MAIN_UI_CHARACTER`、`CHARACTER|{id}`、`CHARACTER_STORY|{id}`。

### 3.2 红点运算单元（RedDotUnit）

- 语义：红点“怎么算”。
- 例如：`CHARACTER_STORY_NEW`、`CHARACTER_CG_NEW`、`MAIN_UI_CHARACTER_NEW`。

### 3.3 Leaf 与 Composite

- Leaf：直接业务函数计算。
- Composite：读取依赖单元结果聚合，不直接读取业务数据。

### 3.4 ID 与非 ID

- 非 ID：全局单值单元。
- 带 ID：`(unit, id)` 维度缓存。
- 两者可混用在同一红点名下。

---

## 4. 关键数据结构（Model 内）

- `_redDotUnitInfoMap: Dictionary<RedDotUnit, RedDotUnitInfo>`
- `_redDotUnitResultMap: Dictionary<RedDotUnit, int>`
- `_redDotUnitResultWithIdMap: Dictionary<RedDotUnitWithId, int>`
- `_redDotInfoMap: Dictionary<string, RedDotInfo>`
- `_redDotUnitNameMap: Dictionary<RedDotUnit, List<string>>`
- `_redDotNameResultMap: Dictionary<string, int>`
- `_redDotUnitWithIdMap: Dictionary<RedDotUnitWithId, List<RedDotNameWithId>>`
- `_redDotUnitDependencyMap: Dictionary<RedDotUnit, List<RedDotUnit>>`

说明：

- `unit -> name` 索引用于 dirty 后快速定位受影响红点名。
- 依赖反向图用于 dirty 递归向上游聚合单元传播。

---

## 5. 初始化与启动时序

典型顺序（`UIInit`）：

1. `RedDotModel.Singleton.Init()`
2. `RedDotManager.Singleton.Init()`
3. 注册动态红点（如角色相关 name）
4. `DoAllRedDotUnitCaculate()` 首次计算缓存
5. 首批 `MarkDirty`（按业务需要）

说明：

- `DoAllRedDotUnitCaculate()` 当前仍有价值：可在首帧形成可回放快照。

---

## 6. 运行时主链路

## 6.1 绑定

- 普通绑定：`BindRedDotName(name, callback)`
- 绑定并回放当前值：`BindRedDotNameAndReplayCurrent(name, callback)`

第二种用于首帧初始化/界面重进，避免“已绑定但当前值未主动推送”的空窗。

## 6.2 标脏

- 非 ID：`MarkRedDotUnitDirty(unit)`
- 带 ID：`MarkRedDotUnitDirty(unit, id)`

两者都会通过依赖图向上游聚合单元递归标脏。

## 6.3 帧更新（Manager.Update）

每 `_dirtyUpdateIntervalFrame` 帧执行一次：

1. `ProcessDirtyRedDotUnitWithId()`
2. `ProcessDirtyRedDotUnit()`

先 ID 后非 ID 的目的：保证聚合单元读取到最新 ID 子结果。

---

## 7. 计算细节

## 7.1 非 ID 通道

入口：`ProcessDirtyRedDotUnit()`

- 收集受影响 redDotName：`CollectChangedRedDotNameMap()`
- 对 name 下相关 unit 进行重算（含去重）
- 批量触发回调：`TriggerRedDotNameUpdate(...)`

## 7.2 带 ID 通道

入口：`ProcessDirtyRedDotUnitWithId()`

- 根据 `(unit,id)` 找到受影响动态 name
- 对每个 name 调用 `DoRedDotNameCalculateWithId(name, id)`
- 批量触发回调：`TriggerRedDotNameUpdateWithId(...)`

## 7.3 当前回调策略

当前策略为：

- dirty 命中的受影响 name 都会触发回调（ID/非 ID 一致）
- 不再限定“仅值变化时回调”

这样可保证 UI 上下文切换（如切角色）在值不变时也能刷新显示。

---

## 8. 聚合单元（Composite）实现

### 8.1 配置方式

在 `RedDotModel` 中通过 `AddCompositeRedDotUnitInfo(...)` 注册：

- 指定 `dependencyUnits`
- 指定 `AggregateMode`
- 自动写入依赖反向索引 `_redDotUnitDependencyMap`

### 8.2 计算方式

`DoRedDotUnitCalculate(...)` 检测 `CalculateMode == COMPOSITE` 时进入 `DoCompositeRedDotUnitCalculate(...)`。

- `ANY_POSITIVE`：任一依赖结果 > 0 即返回 1
- `SUM`：累加依赖结果

对于带 ID 依赖，不扫描业务层角色表，而是通过 `GetRegisteredIdsByUnit(...)` 从红点系统内部已注册映射提取 ID 集合进行聚合。

### 8.3 案例

- `MAIN_UI_CHARACTER_NEW` 作为聚合单元，依赖：
  - `CHARACTER_STORY_NEW`
  - `CHARACTER_CG_NEW`

---

## 9. 动态红点（带 ID）

支持 API：

- `RegisterDynamicRedDot(id, name, des, unit)`
- `RegisterDynamicRedDot(id, name, des, List<unit>)`
- `UnregisterDynamicRedDot(name, id)`

注销时会清理：

- `unit <-> name` 索引
- `RedDotUnitWithId` 映射
- `(unit,id)` 结果缓存

---

## 10. UI 集成规范（当前项目约定）

建议模式：

- Panel 负责红点绑定/解绑/回调处理
- View 只提供展示接口（例如 `SetCharacterRedDot(bool)`）

当前已按该模式落地：

- `CharacterPanel`
- `MainPanel`（已将原 `MonoMainView` 中红点逻辑下沉）

---

## 11. 常用 API 速查

- `BindRedDotName(...)`
- `BindRedDotNameAndReplayCurrent(...)`
- `UnbindRedDotName(...)`
- `MarkRedDotUnitDirty(unit)`
- `MarkRedDotUnitDirty(unit, id)`
- `GetRedDotNameResult(name)`
- `GetRedDotNameResultWithId(name)`
- `TryParseRedDotNameWithId(name, out id)`

---

## 12. 当前方案优点与注意点

优点：

- 计算与显示解耦，易扩展。
- Composite 让静态红点可直接基于动态单元聚合。
- Dirty 增量更新，避免全量重算。
- 绑定回放与“受影响即回调”提高 UI 一致性。

注意点：

- “受影响即回调”会提高回调次数，复杂界面需关注 UI 回调成本。
- 聚合依赖应避免环；当前有 visited 防重复，但配置层仍建议无环。
- 动态红点注册要完整，否则依赖 `GetRegisteredIdsByUnit(...)` 的聚合可能漏算。

---

## 13. 后续可演进方向

- 若后续性能压力增大，可引入“变化过滤 + 强制回放”双通道事件模型。
- 可增加调试面板：展示 dirty 集合、unit 缓存、name 缓存、依赖传播路径。
- 可将 `Dictionary<string,string>` 回调集合改为 `HashSet<string>`，语义更直观。
